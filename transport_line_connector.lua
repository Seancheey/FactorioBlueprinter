---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 9/27/20 5:19 PM
---

require("util")
require("minheap")

--- @type Vector2D[]
local FourWayDirections = {
    Vector2D.fromDirection(defines.direction.north),
    Vector2D.fromDirection(defines.direction.east),
    Vector2D.fromDirection(defines.direction.south),
    Vector2D.fromDirection(defines.direction.west),
}

--- @class TransportChain
--- @field entity LuaEntity
--- @field entityDistance number
--- @field prevChain TransportChain
--- @field cumulativeDistance number
--- @type TransportChain
local TransportChain = {}

--- @param entity LuaEntityPrototype
--- @param prevChain TransportChain
--- @param travelDistance number
--- @return TransportChain
function TransportChain.new(entity, prevChain, travelDistance)
    return setmetatable({
        entity = entity,
        prevChain = prevChain,
        cumulativeDistance = prevChain and (prevChain.cumulativeDistance + (travelDistance or 1)) or 0,
        entityDistance = travelDistance or 1
    }, { __index = TransportChain })
end

--- @return LuaEntity[]|ArrayList
function TransportChain:toEntityList()
    local list = ArrayList.new()
    local currentChain = self
    while currentChain ~= nil do
        list:add(currentChain.entity)
        currentChain = currentChain.prevChain
    end
    return list
end

--- @param transportChain TransportChain
--- @param placeFunc fun(entity: LuaEntityPrototype)
local function placeAllEntities(transportChain, placeFunc)
    while transportChain ~= nil do
        if game.entity_prototypes[transportChain.entity.name].max_underground_distance then
            transportChain.entity.type = "input"
            placeFunc(transportChain.entity)
            -- if the entity is underground line, also place its complement
            placeFunc {
                name = transportChain.entity.name,
                position = Vector2D.fromDirection(transportChain.entity.direction or defines.direction.north):scale(transportChain.entityDistance - 1) + Vector2D.fromPosition(transportChain.entity.position),
                direction = transportChain.entity.direction,
                type = "output"
            }
        else
            placeFunc(transportChain.entity)
        end
        transportChain = transportChain.prevChain
    end
end

--- @class TransportLineConnector
--- @type TransportLineConnector
--- @field canPlaceEntityFunc fun(position: Vector2D): boolean
--- @field placeEntity fun(entity: LuaEntityPrototype)
local TransportLineConnector = {}

TransportLineConnector.__index = TransportLineConnector

--- @param canPlaceEntityFunc fun(position: Vector2D): boolean
--- @return TransportLineConnector
function TransportLineConnector.new(canPlaceEntityFunc, placeEntityFunc)
    assert(canPlaceEntityFunc and placeEntityFunc)
    return setmetatable(
            { canPlaceEntityFunc = canPlaceEntityFunc,
              placeEntityFunc = placeEntityFunc
            }, TransportLineConnector)
end

--- @class LineConnectConfig
--- @field allowUnderground boolean default true
--- @field preferHorizontal boolean default true

--- @param startingEntity LuaEntity
--- @param endingEntity LuaEntity
--- @param additionalConfig LineConnectConfig optional
--- @return LuaEntity[]
function TransportLineConnector:buildTransportLine(startingEntity, endingEntity, additionalConfig)
    assertAllTruthy(self, startingEntity, endingEntity)
    local allowUnderground = (additionalConfig ~= nil and additionalConfig.allowUnderground ~= nil) and additionalConfig.allowUnderground or true
    local preferHorizontal = (additionalConfig ~= nil and additionalConfig.preferHorizontal ~= nil) and additionalConfig.preferHorizontal or true
    local priorityQueue = MinHeap.new()
    -- A* algorithm starts from endingEntity so that we don't have to consider/change last belt's direction
    priorityQueue:push(0, TransportChain.new(endingEntity, nil))
    local tryNum = 10000
    while not priorityQueue:isEmpty() and tryNum > 0 do
        --- @type TransportChain
        local transportChain = priorityQueue:pop().val
        if transportChain.entity.position.x == startingEntity.position.x and transportChain.entity.position.y == startingEntity.position.y then
            placeAllEntities(transportChain, self.placeEntityFunc)
            return
        end
        for entity, travelDistance in pairs(self:surroundingCandidates(transportChain, game.entity_prototypes[startingEntity.name], allowUnderground)) do
            assert(entity and travelDistance)
            local newChain = TransportChain.new(entity, transportChain, travelDistance, travelDistance)
            priorityQueue:push(self:estimateDistance(entity, startingEntity, preferHorizontal, not preferHorizontal) + newChain.cumulativeDistance, newChain)
        end
        tryNum = tryNum - 1
    end
    if priorityQueue:isEmpty() then
        print_log("finding terminated early since there is no more places to find")
    else
        print_log("Failed to connect transport line within 10000 trials")
    end
    return
end

--- @param basePrototype LuaEntityPrototype transport line's base entity prototype
--- @param transportChain TransportChain
--- @return table<LuaEntity, number> entity to its travel distance
function TransportLineConnector:surroundingCandidates(transportChain, basePrototype, allowUnderground)
    assertAllTruthy(self, transportChain, basePrototype, allowUnderground)

    if PrototypeInfo.is_underground_transport(transportChain.entity.name) then
        local testPos = Vector2D.fromDirection(transportChain.entity.direction or defines.direction.north):reverse() + Vector2D.fromPosition(transportChain.entity.position)
        if self.canPlaceEntityFunc(testPos) then
            return { [{
                name = basePrototype.name,
                direction = transportChain.entity.direction,
                position = testPos
            }] = 1 }
        end
    else
        local underground_prototype = PrototypeInfo.underground_transport_prototype(basePrototype.name)
        local candidates = {}
        local bannedPos = Vector2D.fromDirection(transportChain.entity.direction or defines.direction.north)
        for _, direction in ipairs(FourWayDirections) do
            if direction ~= bannedPos then
                -- test if we can place it underground
                if allowUnderground then
                    for underground_distance = underground_prototype.max_underground_distance, 2, -1 do
                        local newPos = direction:scale(underground_distance) + Vector2D.fromPosition(transportChain.entity.position)
                        if self:canPlace(newPos, transportChain) then
                            candidates[{
                                name = underground_prototype.name,
                                direction = direction:reverse():toDirection(),
                                position = newPos
                            }] = underground_distance
                        end
                    end
                end
                -- test if we can place it on ground
                local onGroundPos = direction + Vector2D.fromPosition(transportChain.entity.position)
                if self:canPlace(onGroundPos, transportChain) then
                    candidates[{
                        name = basePrototype.name,
                        direction = direction:reverse():toDirection(),
                        position = onGroundPos
                    }] = 1
                end
            end
        end
        return candidates
    end
end

--- @param position Vector2D
--- @param transportChain TransportChain
function TransportLineConnector:canPlace(position, transportChain)
    assertAllTruthy(self, position, transportChain)

    if not self.canPlaceEntityFunc(position) then
        return false
    end
    while transportChain ~= nil do
        if transportChain.entity.position.x == position.x and transportChain.entity.position.y == position.y then
            return false
        end
        transportChain = transportChain.prevChain
    end
    return true
end

--- A* algorithm's heuristics cost
--- @param entity1 LuaEntity
--- @param entity2 LuaEntity
function TransportLineConnector:estimateDistance(entity1, entity2, rewardHorizontalFirst, rewardVerticalFirst)
    local dx = math.abs(entity1.position.x - entity2.position.x)
    local dy = math.abs(entity1.position.y - entity2.position.y)
    -- break A* cost tie by rewarding going to same y-level, but reward is no more than 1
    local reward = (rewardHorizontalFirst and (1 / (dy + 2)) or 0) + (rewardVerticalFirst and (1 / (dx + 2)) or 0)
    return dx + dy - reward
end

return TransportLineConnector